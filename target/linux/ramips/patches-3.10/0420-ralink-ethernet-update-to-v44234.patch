Index: linux-3.10.49/drivers/net/ethernet/ralink/esw_rt3052.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/esw_rt3052.c	2015-09-25 12:03:54.635000970 +0800
+++ linux-3.10.49/drivers/net/ethernet/ralink/esw_rt3052.c	2015-09-25 10:18:34.373158870 +0800
@@ -192,7 +192,6 @@
 #define RT5350_ESW_REG_PXTPC(_x)	(0x150 + (4 * _x))
 #define RT5350_EWS_REG_LED_POLARITY	0x168
 #define RT5350_RESET_EPHY		BIT(24)
-#define SYSC_REG_RESET_CTRL		0x34
 
 enum {
 	/* Global attributes. */
@@ -512,9 +511,7 @@
 
 	if (ralink_soc == RT305X_SOC_RT3352) {
 		/* reset EPHY */
-		u32 val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val | RT5350_RESET_EPHY, SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+		fe_reset(RT5350_RESET_EPHY);
 
 		rt305x_mii_write(esw, 0, 31, 0x8000);
 		for (i = 0; i < 5; i++) {
@@ -563,9 +560,7 @@
 		rt305x_mii_write(esw, 0, 31, 0x8000);
 	} else if (ralink_soc == RT305X_SOC_RT5350) {
 		/* reset EPHY */
-		u32 val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val | RT5350_RESET_EPHY, SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+		fe_reset(RT5350_RESET_EPHY);
 
 		/* set the led polarity */
 		esw_w32(esw, esw->reg_led_polarity & 0x1F, RT5350_EWS_REG_LED_POLARITY);
@@ -622,9 +617,7 @@
 		u32 val;
 
 		/* reset EPHY */
-		val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val | RT5350_RESET_EPHY, SYSC_REG_RESET_CTRL);
-		rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+		fe_reset(RT5350_RESET_EPHY);
 
 		rt305x_mii_write(esw, 0, 31, 0x2000); /* change G2 page */
 		rt305x_mii_write(esw, 0, 26, 0x0020);
Index: linux-3.10.49/drivers/net/ethernet/ralink/gsw_mt7620a.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/gsw_mt7620a.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/gsw_mt7620a.c
@@ -80,7 +80,6 @@
 
 #define SYSC_REG_CHIP_REV_ID	0x0c
 #define SYSC_REG_CFG1		0x14
-#define SYSC_REG_RESET_CTRL     0x34
 #define RST_CTRL_MCM		BIT(2)
 #define SYSC_PAD_RGMII2_MDIO	0x58
 #define SYSC_GPIO_MODE		0x60
@@ -576,10 +575,7 @@
 	u32	val;
 
 	/* Hardware reset Switch */
-	val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-	rt_sysc_w32(val | RST_CTRL_MCM, SYSC_REG_RESET_CTRL);
-        udelay(1000);
-	rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+	fe_reset(RST_CTRL_MCM);
         udelay(10000);
 
 	/* reduce RGMII2 PAD driving strength */
Index: linux-3.10.49/drivers/net/ethernet/ralink/ralink_ethtool.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/ralink_ethtool.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/ralink_ethtool.c
@@ -140,54 +140,6 @@
 	ring->tx_pending = NUM_DMA_DESC;
 }
 
-static int fe_get_coalesce(struct net_device *dev,
-		struct ethtool_coalesce *coal)
-{
-        u32 delay_cfg = fe_reg_r32(FE_REG_DLY_INT_CFG);
-
-        coal->rx_coalesce_usecs = (delay_cfg & 0xff) * FE_DELAY_TIME;
-        coal->rx_max_coalesced_frames = ((delay_cfg >> 8) & 0x7f);
-        coal->use_adaptive_rx_coalesce = (delay_cfg >> 15) & 0x1;
-
-        coal->tx_coalesce_usecs = ((delay_cfg >> 16 )& 0xff) * FE_DELAY_TIME;
-        coal->tx_max_coalesced_frames = ((delay_cfg >> 24) & 0x7f);
-        coal->use_adaptive_tx_coalesce = (delay_cfg >> 31) & 0x1;
-
-        return 0;
-}
-
-static int fe_set_coalesce(struct net_device *dev,
-		struct ethtool_coalesce *coal)
-{
-	u32 delay_cfg;
-	u32 rx_usecs, tx_usecs;
-	u32 rx_frames, tx_frames;
-
-	if (!coal->use_adaptive_rx_coalesce || !coal->use_adaptive_tx_coalesce)
-		return -EINVAL;
-
-	rx_usecs = DIV_ROUND_UP(coal->rx_coalesce_usecs, FE_DELAY_TIME);
-	rx_frames = coal->rx_max_coalesced_frames;
-	tx_usecs = DIV_ROUND_UP(coal->tx_coalesce_usecs, FE_DELAY_TIME);
-	tx_frames = coal->tx_max_coalesced_frames;
-
-	if (((tx_usecs == 0) && (tx_frames ==0)) ||
-			((rx_usecs == 0) && (rx_frames ==0)))
-		return -EINVAL;
-
-	if (rx_usecs > 0xff) rx_usecs = 0xff;
-	if (rx_frames > 0x7f) rx_frames = 0x7f;
-	if (tx_usecs > 0xff) tx_usecs = 0xff;
-	if (tx_frames > 0x7f) tx_frames = 0x7f;
-
-	delay_cfg = ((((FE_DELAY_EN_INT | tx_frames) << 8) | tx_usecs) << 16) |
-		(((FE_DELAY_EN_INT | rx_frames) << 8) | rx_usecs);
-
-	fe_reg_w32(delay_cfg, FE_REG_DLY_INT_CFG);
-
-	return 0;
-}
-
 static void fe_get_strings(struct net_device *dev, u32 stringset, u8 *data)
 {
 	switch (stringset) {
@@ -243,8 +195,6 @@
 	.nway_reset		= fe_nway_reset,
 	.get_link		= fe_get_link,
 	.get_ringparam		= fe_get_ringparam,
-	.get_coalesce		= fe_get_coalesce,
-	.set_coalesce		= fe_set_coalesce,
 };
 
 void fe_set_ethtool_ops(struct net_device *netdev)
@@ -258,5 +208,5 @@
 		fe_ethtool_ops.get_ethtool_stats = fe_get_ethtool_stats;
 	}
 
-	SET_ETHTOOL_OPS(netdev, &fe_ethtool_ops);
+	netdev->ethtool_ops = &fe_ethtool_ops;
 }
Index: linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.c
@@ -40,11 +40,9 @@
 #include "mdio.h"
 #include "ralink_ethtool.h"
 
-#define TX_TIMEOUT		(2 * HZ)
 #define	MAX_RX_LENGTH		1536
-#define FE_RX_OFFSET		(NET_SKB_PAD + NET_IP_ALIGN)
-#define FE_RX_HLEN		(FE_RX_OFFSET + VLAN_ETH_HLEN + VLAN_HLEN + \
-		ETH_FCS_LEN)
+#define FE_RX_HLEN		(NET_SKB_PAD + VLAN_ETH_HLEN + VLAN_HLEN + \
+		+ NET_IP_ALIGN + ETH_FCS_LEN)
 #define DMA_DUMMY_DESC		0xffffffff
 #define FE_DEFAULT_MSG_ENABLE    \
         (NETIF_MSG_DRV      | \
@@ -61,6 +59,8 @@
 #define NEXT_TX_DESP_IDX(X)	(((X) + 1) & (NUM_DMA_DESC - 1))
 #define NEXT_RX_DESP_IDX(X)	(((X) + 1) & (NUM_DMA_DESC - 1))
 
+#define SYSC_REG_RSTCTRL	0x34
+
 static int fe_msg_level = -1;
 module_param_named(msg_level, fe_msg_level, int, 0);
 MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
@@ -72,9 +72,11 @@
 	[FE_REG_TX_BASE_PTR0] = FE_TX_BASE_PTR0,
 	[FE_REG_TX_MAX_CNT0] = FE_TX_MAX_CNT0,
 	[FE_REG_TX_CTX_IDX0] = FE_TX_CTX_IDX0,
+	[FE_REG_TX_DTX_IDX0] = FE_TX_DTX_IDX0,
 	[FE_REG_RX_BASE_PTR0] = FE_RX_BASE_PTR0,
 	[FE_REG_RX_MAX_CNT0] = FE_RX_MAX_CNT0,
 	[FE_REG_RX_CALC_IDX0] = FE_RX_CALC_IDX0,
+	[FE_REG_RX_DRX_IDX0] = FE_RX_DRX_IDX0,
 	[FE_REG_FE_INT_ENABLE] = FE_FE_INT_ENABLE,
 	[FE_REG_FE_INT_STATUS] = FE_FE_INT_STATUS,
 	[FE_REG_FE_DMA_VID_BASE] = FE_DMA_VID0,
@@ -84,6 +86,11 @@
 
 static const u32 *fe_reg_table = fe_reg_table_default;
 
+struct fe_work_t {
+	int bitnr;
+	void (*action)(struct fe_priv *);
+};
+
 static void __iomem *fe_base = 0;
 
 void fe_w32(u32 val, unsigned reg)
@@ -106,6 +113,20 @@
 	return fe_r32(fe_reg_table[reg]);
 }
 
+void fe_reset(u32 reset_bits)
+{
+	u32 t;
+
+	t = rt_sysc_r32(SYSC_REG_RSTCTRL);
+	t |= reset_bits;
+	rt_sysc_w32(t , SYSC_REG_RSTCTRL);
+	udelay(10);
+
+	t &= ~reset_bits;
+	rt_sysc_w32(t, SYSC_REG_RSTCTRL);
+	udelay(10);
+}
+
 static inline void fe_int_disable(u32 mask)
 {
 	fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) & ~mask,
@@ -157,10 +178,27 @@
 
 static inline int fe_max_buf_size(int frag_size)
 {
-	return frag_size - FE_RX_HLEN -
+	return frag_size - NET_SKB_PAD - NET_IP_ALIGN -
 		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 }
 
+static inline void fe_get_rxd(struct fe_rx_dma *rxd, struct fe_rx_dma *dma_rxd)
+{
+	rxd->rxd1 = dma_rxd->rxd1;
+	rxd->rxd2 = dma_rxd->rxd2;
+	rxd->rxd3 = dma_rxd->rxd3;
+	rxd->rxd4 = dma_rxd->rxd4;
+}
+
+static inline void fe_set_txd(struct fe_tx_dma *txd, struct fe_tx_dma *dma_txd)
+{
+	dma_txd->txd1 = txd->txd1;
+	dma_txd->txd3 = txd->txd3;
+	dma_txd->txd4 = txd->txd4;
+	/* clean dma done flag last */
+	dma_txd->txd2 = txd->txd2;
+}
+
 static void fe_clean_rx(struct fe_priv *priv)
 {
 	int i;
@@ -192,7 +230,7 @@
 static int fe_alloc_rx(struct fe_priv *priv)
 {
 	struct net_device *netdev = priv->netdev;
-	int i;
+	int i, pad;
 
 	priv->rx_data = kcalloc(NUM_DMA_DESC, sizeof(*priv->rx_data),
 			GFP_KERNEL);
@@ -212,17 +250,21 @@
 	if (!priv->rx_dma)
 		goto no_rx_mem;
 
+	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
+		pad = 0;
+	else
+		pad = NET_IP_ALIGN;
 	for (i = 0; i < NUM_DMA_DESC; i++) {
 		dma_addr_t dma_addr = dma_map_single(&netdev->dev,
-				priv->rx_data[i] + FE_RX_OFFSET,
+				priv->rx_data[i] + NET_SKB_PAD + pad,
 				priv->rx_buf_size,
 				DMA_FROM_DEVICE);
 		if (unlikely(dma_mapping_error(&netdev->dev, dma_addr)))
 			goto no_rx_mem;
 		priv->rx_dma[i].rxd1 = (unsigned int) dma_addr;
 
-		if (priv->soc->rx_dma)
-			priv->soc->rx_dma(priv, i, priv->rx_buf_size);
+		if (priv->flags & FE_FLAG_RX_SG_DMA)
+			priv->rx_dma[i].rxd2 = RX_DMA_PLEN0(priv->rx_buf_size);
 		else
 			priv->rx_dma[i].rxd2 = RX_DMA_LSO;
 	}
@@ -239,17 +281,41 @@
 	return -ENOMEM;
 }
 
+static void fe_txd_unmap(struct device *dev, struct fe_tx_buf *tx_buf)
+{
+	if (tx_buf->flags & FE_TX_FLAGS_SINGLE0) {
+		dma_unmap_single(dev,
+				dma_unmap_addr(tx_buf, dma_addr0),
+				dma_unmap_len(tx_buf, dma_len0),
+				DMA_TO_DEVICE);
+	} else if (tx_buf->flags & FE_TX_FLAGS_PAGE0) {
+		dma_unmap_page(dev,
+				dma_unmap_addr(tx_buf, dma_addr0),
+				dma_unmap_len(tx_buf, dma_len0),
+				DMA_TO_DEVICE);
+	}
+	if (tx_buf->flags & FE_TX_FLAGS_PAGE1)
+		dma_unmap_page(dev,
+				dma_unmap_addr(tx_buf, dma_addr1),
+				dma_unmap_len(tx_buf, dma_len1),
+				DMA_TO_DEVICE);
+
+	tx_buf->flags = 0;
+	if (tx_buf->skb && (tx_buf->skb != (struct sk_buff *) DMA_DUMMY_DESC)) {
+		dev_kfree_skb_any(tx_buf->skb);
+	}
+	tx_buf->skb = NULL;
+}
+
 static void fe_clean_tx(struct fe_priv *priv)
 {
 	int i;
 
-	if (priv->tx_skb) {
-		for (i = 0; i < NUM_DMA_DESC; i++) {
-			if (priv->tx_skb[i])
-				dev_kfree_skb_any(priv->tx_skb[i]);
-		}
-		kfree(priv->tx_skb);
-		priv->tx_skb = NULL;
+	if (priv->tx_buf) {
+		for (i = 0; i < NUM_DMA_DESC; i++)
+			fe_txd_unmap(&priv->netdev->dev, &priv->tx_buf[i]);
+		kfree(priv->tx_buf);
+		priv->tx_buf = NULL;
 	}
 
 	if (priv->tx_dma) {
@@ -267,9 +333,9 @@
 
 	priv->tx_free_idx = 0;
 
-	priv->tx_skb = kcalloc(NUM_DMA_DESC, sizeof(*priv->tx_skb),
+	priv->tx_buf = kcalloc(NUM_DMA_DESC, sizeof(*priv->tx_buf),
 			GFP_KERNEL);
-	if (!priv->tx_skb)
+	if (!priv->tx_buf)
 		goto no_tx_mem;
 
 	priv->tx_dma = dma_alloc_coherent(&priv->netdev->dev,
@@ -281,8 +347,7 @@
 
 	for (i = 0; i < NUM_DMA_DESC; i++) {
 		if (priv->soc->tx_dma) {
-			priv->soc->tx_dma(priv, i, NULL);
-			continue;
+			priv->soc->tx_dma(&priv->tx_dma[i]);
 		}
 		priv->tx_dma[i].txd2 = TX_DMA_DESP2_DEF;
 	}
@@ -322,39 +387,19 @@
 	netdev_reset_queue(priv->netdev);
 }
 
-static inline void txd_unmap_single(struct device *dev, struct fe_tx_dma *txd)
-{
-	if (txd->txd1 && TX_DMA_GET_PLEN0(txd->txd2))
-		dma_unmap_single(dev, txd->txd1,
-				TX_DMA_GET_PLEN0(txd->txd2),
-				DMA_TO_DEVICE);
-}
-
-static inline void txd_unmap_page0(struct device *dev, struct fe_tx_dma *txd)
-{
-	if (txd->txd1 && TX_DMA_GET_PLEN0(txd->txd2))
-		dma_unmap_page(dev, txd->txd1,
-				TX_DMA_GET_PLEN0(txd->txd2),
-				DMA_TO_DEVICE);
-}
-
-static inline void txd_unmap_page1(struct device *dev, struct fe_tx_dma *txd)
-{
-	if (txd->txd3 && TX_DMA_GET_PLEN1(txd->txd2))
-		dma_unmap_page(dev, txd->txd3,
-				TX_DMA_GET_PLEN1(txd->txd2),
-				DMA_TO_DEVICE);
-}
-
 void fe_stats_update(struct fe_priv *priv)
 {
 	struct fe_hw_stats *hwstats = priv->hw_stats;
 	unsigned int base = fe_reg_table[FE_REG_FE_COUNTER_BASE];
+	u64 stats;
 
 	u64_stats_update_begin(&hwstats->syncp);
 
 	if (IS_ENABLED(CONFIG_SOC_MT7621)) {
 		hwstats->rx_bytes			+= fe_r32(base);
+		stats					=  fe_r32(base + 0x04);
+		if (stats)
+			hwstats->rx_bytes		+= (stats << 32);
 		hwstats->rx_packets			+= fe_r32(base + 0x08);
 		hwstats->rx_overflow			+= fe_r32(base + 0x10);
 		hwstats->rx_fcs_errors			+= fe_r32(base + 0x14);
@@ -365,6 +410,9 @@
 		hwstats->tx_skip			+= fe_r32(base + 0x28);
 		hwstats->tx_collisions			+= fe_r32(base + 0x2c);
 		hwstats->tx_bytes			+= fe_r32(base + 0x30);
+		stats					=  fe_r32(base + 0x34);
+		if (stats)
+			hwstats->tx_bytes		+= (stats << 32);
 		hwstats->tx_packets			+= fe_r32(base + 0x38);
 	} else {
 		hwstats->tx_bytes			+= fe_r32(base);
@@ -434,7 +482,7 @@
 	u32 vlan_cfg;
 
 	if (!((fe_reg_table[FE_REG_FE_DMA_VID_BASE]) &&
-			(dev->features | NETIF_F_HW_VLAN_CTAG_TX)))
+			(dev->features & NETIF_F_HW_VLAN_CTAG_TX)))
 		return 0;
 
 	if (test_bit(idx, &priv->vlan_map)) {
@@ -475,40 +523,39 @@
 }
 
 static int fe_tx_map_dma(struct sk_buff *skb, struct net_device *dev,
-		int idx)
+		int idx, int tx_num)
 {
 	struct fe_priv *priv = netdev_priv(dev);
 	struct skb_frag_struct *frag;
-	struct fe_tx_dma *txd;
+	struct fe_tx_dma txd, *ptxd;
+	struct fe_tx_buf *tx_buf;
 	dma_addr_t mapped_addr;
 	unsigned int nr_frags;
-	u32 def_txd4, txd2;
-	int i, j, unmap_idx, tx_num;
+	u32 def_txd4;
+	int i, j, k, frag_size, frag_map_size, offset;
 
-	txd = &priv->tx_dma[idx];
+	tx_buf = &priv->tx_buf[idx];
+	memset(tx_buf, 0, sizeof(*tx_buf));
+	memset(&txd, 0, sizeof(txd));
 	nr_frags = skb_shinfo(skb)->nr_frags;
-	tx_num = 1 + (nr_frags >> 1);
 
 	/* init tx descriptor */
 	if (priv->soc->tx_dma)
-		priv->soc->tx_dma(priv, idx, skb);
+		priv->soc->tx_dma(&txd);
 	else
-		txd->txd4 = TX_DMA_DESP4_DEF;
-	def_txd4 = txd->txd4;
-
-	/* use dma_unmap_single to free it */
-	txd->txd4 |= priv->soc->tx_udf_bit;
+		txd.txd4 = TX_DMA_DESP4_DEF;
+	def_txd4 = txd.txd4;
 
 	/* TX Checksum offload */
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		txd->txd4 |= TX_DMA_CHKSUM;
+		txd.txd4 |= TX_DMA_CHKSUM;
 
 	/* VLAN header offload */
 	if (vlan_tx_tag_present(skb)) {
 		if (IS_ENABLED(CONFIG_SOC_MT7621))
-			txd->txd4 |= TX_DMA_INS_VLAN_MT7621 | vlan_tx_tag_get(skb);
+			txd.txd4 |= TX_DMA_INS_VLAN_MT7621 | vlan_tx_tag_get(skb);
 		else
-			txd->txd4 |= TX_DMA_INS_VLAN |
+			txd.txd4 |= TX_DMA_INS_VLAN |
 				((vlan_tx_tag_get(skb) >> VLAN_PRIO_SHIFT) << 4) |
 				(vlan_tx_tag_get(skb) & 0xF);
 	}
@@ -522,7 +569,7 @@
 		}
 		if (skb_shinfo(skb)->gso_type &
 				(SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {
-			txd->txd4 |= TX_DMA_TSO;
+			txd.txd4 |= TX_DMA_TSO;
 			tcp_hdr(skb)->check = htons(skb_shinfo(skb)->gso_size);
 		}
 	}
@@ -531,76 +578,95 @@
 			skb_headlen(skb), DMA_TO_DEVICE);
 	if (unlikely(dma_mapping_error(&dev->dev, mapped_addr)))
 		goto err_out;
-	txd->txd1 = mapped_addr;
-	txd2 = TX_DMA_PLEN0(skb_headlen(skb));
+	txd.txd1 = mapped_addr;
+	txd.txd2 = TX_DMA_PLEN0(skb_headlen(skb));
+
+	tx_buf->flags |= FE_TX_FLAGS_SINGLE0;
+	dma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);
+	dma_unmap_len_set(tx_buf, dma_len0, skb_headlen(skb));
 
 	/* TX SG offload */
 	j = idx;
+	k = 0;
 	for (i = 0; i < nr_frags; i++) {
-
+		offset = 0;
 		frag = &skb_shinfo(skb)->frags[i];
-		mapped_addr = skb_frag_dma_map(&dev->dev, frag, 0,
-				skb_frag_size(frag), DMA_TO_DEVICE);
-		if (unlikely(dma_mapping_error(&dev->dev, mapped_addr)))
-			goto err_dma;
-
-		if (i & 0x1) {
-			j = NEXT_TX_DESP_IDX(j);
-			txd = &priv->tx_dma[j];
-			txd->txd1 = mapped_addr;
-			txd2 = TX_DMA_PLEN0(frag->size);
-			txd->txd4 = def_txd4;
-		} else {
-			txd->txd3 = mapped_addr;
-			txd2 |= TX_DMA_PLEN1(frag->size);
-			if (i != (nr_frags -1))
-				txd->txd2 = txd2;
-			priv->tx_skb[j] = (struct sk_buff *) DMA_DUMMY_DESC;
+		frag_size = skb_frag_size(frag);
+
+		while (frag_size > 0) {
+			frag_map_size = min(frag_size, TX_DMA_BUF_LEN);
+			mapped_addr = skb_frag_dma_map(&dev->dev, frag, offset,
+					frag_map_size, DMA_TO_DEVICE);
+			if (unlikely(dma_mapping_error(&dev->dev, mapped_addr)))
+				goto err_dma;
+
+			if (k & 0x1) {
+				j = NEXT_TX_DESP_IDX(j);
+				txd.txd1 = mapped_addr;
+				txd.txd2 = TX_DMA_PLEN0(frag_map_size);
+				txd.txd4 = def_txd4;
+
+				tx_buf = &priv->tx_buf[j];
+				memset(tx_buf, 0, sizeof(*tx_buf));
+
+				tx_buf->flags |= FE_TX_FLAGS_PAGE0;
+				dma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);
+				dma_unmap_len_set(tx_buf, dma_len0, frag_map_size);
+			} else {
+				txd.txd3 = mapped_addr;
+				txd.txd2 |= TX_DMA_PLEN1(frag_map_size);
+
+				tx_buf->skb = (struct sk_buff *) DMA_DUMMY_DESC;
+				tx_buf->flags |= FE_TX_FLAGS_PAGE1;
+				dma_unmap_addr_set(tx_buf, dma_addr1, mapped_addr);
+				dma_unmap_len_set(tx_buf, dma_len1, frag_map_size);
+
+				if (!((i == (nr_frags -1)) &&
+							(frag_map_size == frag_size))) {
+					fe_set_txd(&txd, &priv->tx_dma[j]);
+					memset(&txd, 0, sizeof(txd));
+				}
+			}
+			frag_size -= frag_map_size;
+			offset += frag_map_size;
+			k++;
 		}
 	}
 
 	/* set last segment */
-	if (nr_frags & 0x1)
-		txd->txd2 = (txd2 | TX_DMA_LS1);
+	if (k & 0x1)
+		txd.txd2 |= TX_DMA_LS1;
 	else
-		txd->txd2 = (txd2 | TX_DMA_LS0);
+		txd.txd2 |= TX_DMA_LS0;
+	fe_set_txd(&txd, &priv->tx_dma[j]);
 
 	/* store skb to cleanup */
-	priv->tx_skb[j] = skb;
+	tx_buf->skb = skb;
+
+	netdev_sent_queue(dev, skb->len);
+	skb_tx_timestamp(skb);
 
-	wmb();
 	j = NEXT_TX_DESP_IDX(j);
+	wmb();
 	fe_reg_w32(j, FE_REG_TX_CTX_IDX0);
 
 	return 0;
 
 err_dma:
-	/* unmap dma */
-	txd = &priv->tx_dma[idx];
-	txd_unmap_single(&dev->dev, txd);
-
-	j = idx;
-	unmap_idx = i;
-	for (i = 0; i < unmap_idx; i++) {
-		if (i & 0x1) {
-			j = NEXT_TX_DESP_IDX(j);
-			txd = &priv->tx_dma[j];
-			txd_unmap_page0(&dev->dev, txd);
-		} else {
-			txd_unmap_page1(&dev->dev, txd);
-		}
-	}
-
-err_out:
-	/* reinit descriptors and skb */
 	j = idx;
 	for (i = 0; i < tx_num; i++) {
-		priv->tx_dma[j].txd2 = TX_DMA_DESP2_DEF;
-		priv->tx_skb[j] = NULL;
+		ptxd = &priv->tx_dma[j];
+		tx_buf = &priv->tx_buf[j];
+
+		/* unmap dma */
+		fe_txd_unmap(&dev->dev, tx_buf);
+
+		ptxd->txd2 = TX_DMA_DESP2_DEF;
 		j = NEXT_TX_DESP_IDX(j);
 	}
 	wmb();
 
+err_out:
 	return -1;
 }
 
@@ -640,44 +706,54 @@
 				(NUM_DMA_DESC - 1)));
 }
 
+static inline int fe_cal_txd_req(struct sk_buff *skb)
+{
+	int i, nfrags;
+	struct skb_frag_struct *frag;
+
+	nfrags = 1;
+	if (skb_is_gso(skb)) {
+		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
+			frag = &skb_shinfo(skb)->frags[i];
+			nfrags += DIV_ROUND_UP(frag->size, TX_DMA_BUF_LEN);
+		}
+	} else {
+		nfrags += skb_shinfo(skb)->nr_frags;
+	}
+
+	return DIV_ROUND_UP(nfrags, 2);
+}
+
 static int fe_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct fe_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &dev->stats;
 	u32 tx;
 	int tx_num;
+	int len = skb->len;
 
 	if (fe_skb_padto(skb, priv)) {
 		netif_warn(priv, tx_err, dev, "tx padding failed!\n");
 		return NETDEV_TX_OK;
 	}
 
-	spin_lock(&priv->page_lock);
-	tx_num = 1 + (skb_shinfo(skb)->nr_frags >> 1);
+	tx_num = fe_cal_txd_req(skb);
 	tx = fe_reg_r32(FE_REG_TX_CTX_IDX0);
 	if (unlikely(fe_empty_txd(priv, tx) <= tx_num))
 	{
 		netif_stop_queue(dev);
-		spin_unlock(&priv->page_lock);
 		netif_err(priv, tx_queued,dev,
 				"Tx Ring full when queue awake!\n");
 		return NETDEV_TX_BUSY;
 	}
 
-	if (fe_tx_map_dma(skb, dev, tx) < 0) {
-		kfree_skb(skb);
-
+	if (fe_tx_map_dma(skb, dev, tx, tx_num) < 0) {
 		stats->tx_dropped++;
 	} else {
-		netdev_sent_queue(dev, skb->len);
-		skb_tx_timestamp(skb);
-
 		stats->tx_packets++;
-		stats->tx_bytes += skb->len;
+		stats->tx_bytes += len;
 	}
 
-	spin_unlock(&priv->page_lock);
-
 	return NETDEV_TX_OK;
 }
 
@@ -696,7 +772,7 @@
 }
 
 static int fe_poll_rx(struct napi_struct *napi, int budget,
-		struct fe_priv *priv)
+		struct fe_priv *priv, u32 rx_intr)
 {
 	struct net_device *netdev = priv->netdev;
 	struct net_device_stats *stats = &netdev->stats;
@@ -705,8 +781,8 @@
 	int idx = fe_reg_r32(FE_REG_RX_CALC_IDX0);
 	struct sk_buff *skb;
 	u8 *data, *new_data;
-	struct fe_rx_dma *rxd;
-	int done = 0;
+	struct fe_rx_dma *rxd, trxd;
+	int done = 0, pad;
 	bool rx_vlan = netdev->features & NETIF_F_HW_VLAN_CTAG_RX;
 
 	if (netdev->features & NETIF_F_RXCSUM)
@@ -714,6 +790,11 @@
 	else
 		checksum_bit = 0;
 
+	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
+		pad = 0;
+	else
+		pad = NET_IP_ALIGN;
+
 	while (done < budget) {
 		unsigned int pktlen;
 		dma_addr_t dma_addr;
@@ -721,7 +802,8 @@
 		rxd = &priv->rx_dma[idx];
 		data = priv->rx_data[idx];
 
-		if (!(rxd->rxd2 & RX_DMA_DONE))
+		fe_get_rxd(&trxd, rxd);
+		if (!(trxd.rxd2 & RX_DMA_DONE))
 			break;
 
 		/* alloc new buffer */
@@ -731,7 +813,7 @@
 			goto release_desc;
 		}
 		dma_addr = dma_map_single(&netdev->dev,
-				new_data + FE_RX_OFFSET,
+				new_data + NET_SKB_PAD + pad,
 				priv->rx_buf_size,
 				DMA_FROM_DEVICE);
 		if (unlikely(dma_mapping_error(&netdev->dev, dma_addr))) {
@@ -745,14 +827,14 @@
 			put_page(virt_to_head_page(new_data));
 			goto release_desc;
 		}
-		skb_reserve(skb, FE_RX_OFFSET);
+		skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
 
-		dma_unmap_single(&netdev->dev, rxd->rxd1,
+		dma_unmap_single(&netdev->dev, trxd.rxd1,
 				priv->rx_buf_size, DMA_FROM_DEVICE);
-		pktlen = RX_DMA_PLEN0(rxd->rxd2);
-		skb_put(skb, pktlen);
+		pktlen = RX_DMA_PLEN0(trxd.rxd2);
 		skb->dev = netdev;
-		if (rxd->rxd4 & checksum_bit) {
+		skb_put(skb, pktlen);
+		if (trxd.rxd4 & checksum_bit) {
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 		} else {
 			skb_checksum_none_assert(skb);
@@ -770,8 +852,8 @@
 		rxd->rxd1 = (unsigned int) dma_addr;
 
 release_desc:
-		if (soc->rx_dma)
-			soc->rx_dma(priv, idx, priv->rx_buf_size);
+		if (priv->flags & FE_FLAG_RX_SG_DMA)
+			rxd->rxd2 = RX_DMA_PLEN0(priv->rx_buf_size);
 		else
 			rxd->rxd2 = RX_DMA_LSO;
 
@@ -780,40 +862,39 @@
 		done++;
 	}
 
+	if (done < budget)
+		fe_reg_w32(rx_intr, FE_REG_FE_INT_STATUS);
+
 	return done;
 }
 
-static int fe_poll_tx(struct fe_priv *priv, int budget)
+static int fe_poll_tx(struct fe_priv *priv, int budget, u32 tx_intr)
 {
 	struct net_device *netdev = priv->netdev;
 	struct device *dev = &netdev->dev;
 	unsigned int bytes_compl = 0;
 	struct sk_buff *skb;
-	struct fe_tx_dma *txd;
-	int done = 0, idx;
-	u32 udf_bit = priv->soc->tx_udf_bit;
+	struct fe_tx_buf *tx_buf;
+	int done = 0;
+	u32 idx, hwidx;
 
+	hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);
 	idx = priv->tx_free_idx;
-	while (done < budget) {
-		txd = &priv->tx_dma[idx];
-		skb = priv->tx_skb[idx];
 
-		if (!(txd->txd2 & TX_DMA_DONE) || !skb)
-			break;
-
-		txd_unmap_page1(dev, txd);
+txpoll_again:
+	while ((idx != hwidx) && budget) {
+		tx_buf = &priv->tx_buf[idx];
+		skb = tx_buf->skb;
 
-		if (txd->txd4 & udf_bit)
-			txd_unmap_single(dev, txd);
-		else
-			txd_unmap_page0(dev, txd);
+		if (!skb)
+			break;
 
 		if (skb != (struct sk_buff *) DMA_DUMMY_DESC) {
 			bytes_compl += skb->len;
-			dev_kfree_skb_any(skb);
 			done++;
+			budget--;
 		}
-		priv->tx_skb[idx] = NULL;
+		fe_txd_unmap(dev, tx_buf);
 		idx = NEXT_TX_DESP_IDX(idx);
 	}
 	priv->tx_free_idx = idx;
@@ -821,6 +902,13 @@
 	if (!done)
 		return 0;
 
+	if (budget) {
+		fe_reg_w32(tx_intr, FE_REG_FE_INT_STATUS);
+		hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);
+		if (idx != hwidx)
+			goto txpoll_again;
+	}
+
 	netdev_completed_queue(netdev, done, bytes_compl);
 	if (unlikely(netif_queue_stopped(netdev) &&
 				netif_carrier_ok(netdev))) {
@@ -839,25 +927,15 @@
 	u32 tx_intr, rx_intr;
 
 	status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-	tx_intr = priv->soc->tx_dly_int;
-	rx_intr = priv->soc->rx_dly_int;
+	tx_intr = priv->soc->tx_int;
+	rx_intr = priv->soc->rx_int;
 	tx_done = rx_done = 0;
 
-poll_again:
-	if (status & tx_intr) {
-		tx_done += fe_poll_tx(priv, budget - tx_done);
-		if (tx_done < budget) {
-			fe_reg_w32(tx_intr, FE_REG_FE_INT_STATUS);
-		}
-		status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-	}
+	if (status & tx_intr)
+		tx_done = fe_poll_tx(priv, budget, tx_intr);
 
-	if (status & rx_intr) {
-		rx_done += fe_poll_rx(napi, budget - rx_done, priv);
-		if (rx_done < budget) {
-			fe_reg_w32(rx_intr, FE_REG_FE_INT_STATUS);
-		}
-	}
+	if (status & rx_intr)
+		rx_done = fe_poll_rx(napi, budget, priv, rx_intr);
 
 	if (unlikely(hwstat && (status & FE_CNT_GDM_AF))) {
 		if (spin_trylock(&hwstat->stats_lock)) {
@@ -870,19 +948,20 @@
 	if (unlikely(netif_msg_intr(priv))) {
 		mask = fe_reg_r32(FE_REG_FE_INT_ENABLE);
 		netdev_info(priv->netdev,
-				"done tx %d, rx %d, intr 0x%x/0x%x\n",
+				"done tx %d, rx %d, intr 0x%08x/0x%x\n",
 				tx_done, rx_done, status, mask);
 	}
 
 	if ((tx_done < budget) && (rx_done < budget)) {
 		status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-		if (status & (tx_intr | rx_intr )) {
+		if (status & (tx_intr | rx_intr ))
 			goto poll_again;
-		}
+
 		napi_complete(napi);
 		fe_int_enable(tx_intr | rx_intr);
 	}
 
+poll_again:
 	return rx_done;
 }
 
@@ -892,29 +971,45 @@
 
 	priv->netdev->stats.tx_errors++;
 	netif_err(priv, tx_err, dev,
-			"transmit timed out, waking up the queue\n");
-	netif_info(priv, drv, dev, ": dma_cfg:%08x, free_idx:%d, " \
-			"dma_ctx_idx=%u, dma_crx_idx=%u\n",
-			fe_reg_r32(FE_REG_PDMA_GLO_CFG), priv->tx_free_idx,
+			"transmit timed out\n");
+	netif_info(priv, drv, dev, "dma_cfg:%08x\n",
+			fe_reg_r32(FE_REG_PDMA_GLO_CFG));
+	netif_info(priv, drv, dev, "tx_ring=%d, " \
+			"base=%08x, max=%u, ctx=%u, dtx=%u, fdx=%d\n", 0,
+			fe_reg_r32(FE_REG_TX_BASE_PTR0),
+			fe_reg_r32(FE_REG_TX_MAX_CNT0),
 			fe_reg_r32(FE_REG_TX_CTX_IDX0),
-			fe_reg_r32(FE_REG_RX_CALC_IDX0));
-	netif_wake_queue(dev);
+			fe_reg_r32(FE_REG_TX_DTX_IDX0),
+			priv->tx_free_idx
+		  );
+	netif_info(priv, drv, dev, "rx_ring=%d, " \
+			"base=%08x, max=%u, calc=%u, drx=%u\n", 0,
+			fe_reg_r32(FE_REG_RX_BASE_PTR0),
+			fe_reg_r32(FE_REG_RX_MAX_CNT0),
+			fe_reg_r32(FE_REG_RX_CALC_IDX0),
+			fe_reg_r32(FE_REG_RX_DRX_IDX0)
+		  );
+
+	if (!test_and_set_bit(FE_FLAG_RESET_PENDING, priv->pending_flags))
+		schedule_work(&priv->pending_work);
 }
 
 static irqreturn_t fe_handle_irq(int irq, void *dev)
 {
 	struct fe_priv *priv = netdev_priv(dev);
-	u32 status, dly_int;
+	u32 status, int_mask;
 
 	status = fe_reg_r32(FE_REG_FE_INT_STATUS);
 
 	if (unlikely(!status))
 		return IRQ_NONE;
 
-	dly_int = (priv->soc->rx_dly_int | priv->soc->tx_dly_int);
-	if (likely(status & dly_int)) {
-		fe_int_disable(dly_int);
-		napi_schedule(&priv->rx_napi);
+	int_mask = (priv->soc->rx_int | priv->soc->tx_int);
+	if (likely(status & int_mask)) {
+		if (likely(napi_schedule_prep(&priv->rx_napi))) {
+			fe_int_disable(int_mask);
+			__napi_schedule(&priv->rx_napi);
+		}
 	} else {
 		fe_reg_w32(status, FE_REG_FE_INT_STATUS);
 	}
@@ -926,11 +1021,11 @@
 static void fe_poll_controller(struct net_device *dev)
 {
 	struct fe_priv *priv = netdev_priv(dev);
-	u32 dly_int = priv->soc->tx_dly_int | priv->soc->rx_dly_int;
+	u32 int_mask = priv->soc->tx_int | priv->soc->rx_int;
 
-	fe_int_disable(dly_int);
+	fe_int_disable(int_mask);
 	fe_handle_irq(dev->irq, dev);
-	fe_int_enable(dly_int);
+	fe_int_enable(int_mask);
 }
 #endif
 
@@ -1015,9 +1110,10 @@
 	else
 		fe_hw_set_macaddr(priv, dev->dev_addr);
 
-	fe_reg_w32(FE_DELAY_INIT, FE_REG_DLY_INT_CFG);
+	/* disable delay interrupt */
+	fe_reg_w32(0, FE_REG_DLY_INT_CFG);
 
-	fe_int_disable(priv->soc->tx_dly_int | priv->soc->rx_dly_int);
+	fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);
 
         /* frame engine will push VLAN tag regarding to VIDX feild in Tx desc. */
 	if (fe_reg_table[FE_REG_FE_DMA_VID_BASE])
@@ -1053,6 +1149,8 @@
 	napi_enable(&priv->rx_napi);
 
 	val = FE_TX_WB_DDONE | FE_RX_DMA_EN | FE_TX_DMA_EN;
+	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
+		val |= FE_RX_2B_OFFSET;
 	val |= priv->soc->pdma_glo_cfg;
 	fe_reg_w32(val, FE_REG_PDMA_GLO_CFG);
 
@@ -1065,7 +1163,7 @@
 		netif_carrier_on(dev);
 
 	netif_start_queue(dev);
-	fe_int_enable(priv->soc->tx_dly_int | priv->soc->rx_dly_int);
+	fe_int_enable(priv->soc->tx_int | priv->soc->rx_int);
 
 	return 0;
 
@@ -1080,7 +1178,7 @@
 	unsigned long flags;
 	int i;
 
-	fe_int_disable(priv->soc->tx_dly_int | priv->soc->rx_dly_int);
+	fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);
 
 	netif_tx_disable(dev);
 
@@ -1122,8 +1220,10 @@
 	if (priv->soc->switch_init)
 		priv->soc->switch_init(priv);
 
-	memcpy(dev->dev_addr, priv->soc->mac, ETH_ALEN);
 	of_get_mac_address_mtd(priv->device->of_node, dev->dev_addr);
+	/*If the mac address is invalid, use default mac address  */
+	if (!is_valid_ether_addr(dev->dev_addr))
+		memcpy(dev->dev_addr, priv->soc->mac, ETH_ALEN);
 
 	err = fe_mdio_init(priv);
 	if (err)
@@ -1213,13 +1313,11 @@
 	if (old_mtu > ETH_DATA_LEN && new_mtu > ETH_DATA_LEN)
 		return 0;
 
-	if (new_mtu <= ETH_DATA_LEN) {
+	if (new_mtu <= ETH_DATA_LEN)
 		priv->frag_size = fe_max_frag_size(ETH_DATA_LEN);
-		priv->rx_buf_size = fe_max_buf_size(ETH_DATA_LEN);
-	} else {
+	else
 		priv->frag_size = PAGE_SIZE;
-		priv->rx_buf_size = fe_max_buf_size(PAGE_SIZE);
-	}
+	priv->rx_buf_size = fe_max_buf_size(priv->frag_size);
 
 	if (!netif_running(dev))
 		return 0;
@@ -1257,6 +1355,45 @@
 #endif
 };
 
+static void fe_reset_pending(struct fe_priv *priv)
+{
+	struct net_device *dev = priv->netdev;
+	int err;
+
+	rtnl_lock();
+	fe_stop(dev);
+
+	err = fe_open(dev);
+	if (err)
+		goto error;
+	rtnl_unlock();
+
+	return;
+error:
+	netif_alert(priv, ifup, dev,
+			"Driver up/down cycle failed, closing device.\n");
+	dev_close(dev);
+	rtnl_unlock();
+}
+
+static const struct fe_work_t fe_work[] = {
+	{FE_FLAG_RESET_PENDING, fe_reset_pending},
+};
+
+static void fe_pending_work(struct work_struct *work)
+{
+	struct fe_priv *priv = container_of(work, struct fe_priv, pending_work);
+	int i;
+	bool pending;
+
+	for (i = 0; i < ARRAY_SIZE(fe_work); i++) {
+		pending = test_and_clear_bit(fe_work[i].bitnr,
+				priv->pending_flags);
+		if (pending)
+			fe_work[i].action(priv);
+	}
+}
+
 static int fe_probe(struct platform_device *pdev)
 {
 	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1265,7 +1402,7 @@
 	struct net_device *netdev;
 	struct fe_priv *priv;
 	struct clk *sysclk;
-	int err;
+	int err, napi_weight;
 
 	device_reset(&pdev->dev);
 
@@ -1293,7 +1430,6 @@
 	SET_NETDEV_DEV(netdev, &pdev->dev);
 	netdev->netdev_ops = &fe_netdev_ops;
 	netdev->base_addr = (unsigned long) fe_base;
-	netdev->watchdog_timeo = TX_TIMEOUT;
 
 	netdev->irq = platform_get_irq(pdev, 0);
 	if (netdev->irq < 0) {
@@ -1334,14 +1470,18 @@
 	priv->soc = soc;
 	priv->msg_enable = netif_msg_init(fe_msg_level, FE_DEFAULT_MSG_ENABLE);
 	priv->frag_size = fe_max_frag_size(ETH_DATA_LEN);
-	priv->rx_buf_size = fe_max_buf_size(ETH_DATA_LEN);
+	priv->rx_buf_size = fe_max_buf_size(priv->frag_size);
 	if (priv->frag_size > PAGE_SIZE) {
 		dev_err(&pdev->dev, "error frag size.\n");
 		err = -EINVAL;
 		goto err_free_dev;
 	}
+	INIT_WORK(&priv->pending_work, fe_pending_work);
 
-	netif_napi_add(netdev, &priv->rx_napi, fe_poll, 32);
+	napi_weight = 32;
+	if (priv->flags & FE_FLAG_NAPI_WEIGHT)
+		napi_weight = 64;
+	netif_napi_add(netdev, &priv->rx_napi, fe_poll, napi_weight);
 	fe_set_ethtool_ops(netdev);
 
 	err = register_netdev(netdev);
@@ -1374,6 +1514,8 @@
 	if (priv->hw_stats)
 		kfree(priv->hw_stats);
 
+	cancel_work_sync(&priv->pending_work);
+
 	unregister_netdev(dev);
 	free_netdev(dev);
 	platform_set_drvdata(pdev, NULL);
Index: linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.h
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.h
+++ linux-3.10.49/drivers/net/ethernet/ralink/ralink_soc_eth.h
@@ -33,9 +33,11 @@
 	FE_REG_TX_BASE_PTR0,
 	FE_REG_TX_MAX_CNT0,
 	FE_REG_TX_CTX_IDX0,
+	FE_REG_TX_DTX_IDX0,
 	FE_REG_RX_BASE_PTR0,
 	FE_REG_RX_MAX_CNT0,
 	FE_REG_RX_CALC_IDX0,
+	FE_REG_RX_DRX_IDX0,
 	FE_REG_FE_INT_ENABLE,
 	FE_REG_FE_INT_STATUS,
 	FE_REG_FE_DMA_VID_BASE,
@@ -44,10 +46,19 @@
 	FE_REG_COUNT
 };
 
-#define FE_DRV_VERSION		"0.1.0"
+enum fe_work_flag {
+        FE_FLAG_RESET_PENDING,
+        FE_FLAG_MAX
+};
+
+#define FE_DRV_VERSION		"0.1.2"
 
 /* power of 2 to let NEXT_TX_DESP_IDX work */
+#ifdef CONFIG_SOC_MT7621
+#define NUM_DMA_DESC		(1 << 9)
+#else
 #define NUM_DMA_DESC		(1 << 7)
+#endif
 #define MAX_DMA_DESC		0xfff
 
 #define FE_DELAY_EN_INT		0x80
@@ -79,8 +90,22 @@
 #define FE_TX_DLY_INT		BIT(1)
 #define FE_RX_DLY_INT		BIT(0)
 
+#define FE_RX_DONE_INT		FE_RX_DONE_INT0
+#define FE_TX_DONE_INT		(FE_TX_DONE_INT0 | FE_TX_DONE_INT1 | \
+				 FE_TX_DONE_INT2 | FE_TX_DONE_INT3)
+
 #define RT5350_RX_DLY_INT	BIT(30)
 #define RT5350_TX_DLY_INT	BIT(28)
+#define RT5350_RX_DONE_INT1	BIT(17)
+#define RT5350_RX_DONE_INT0	BIT(16)
+#define RT5350_TX_DONE_INT3	BIT(3)
+#define RT5350_TX_DONE_INT2	BIT(2)
+#define RT5350_TX_DONE_INT1	BIT(1)
+#define RT5350_TX_DONE_INT0	BIT(0)
+
+#define RT5350_RX_DONE_INT	(RT5350_RX_DONE_INT0 | RT5350_RX_DONE_INT1)
+#define RT5350_TX_DONE_INT	(RT5350_TX_DONE_INT0 | RT5350_TX_DONE_INT1 | \
+				 RT5350_TX_DONE_INT2 | RT5350_TX_DONE_INT3)
 
 /* registers */
 #define FE_FE_OFFSET		0x0000
@@ -264,6 +289,7 @@
 #define FE_PST_DTX_IDX1		BIT(1)
 #define FE_PST_DTX_IDX0		BIT(0)
 
+#define FE_RX_2B_OFFSET		BIT(31)
 #define FE_TX_WB_DDONE		BIT(6)
 #define FE_RX_DMA_BUSY		BIT(3)
 #define FE_TX_DMA_BUSY		BIT(1)
@@ -278,9 +304,15 @@
 #define FE_US_CYC_CNT_SHIFT	0x8
 #define FE_US_CYC_CNT_DIVISOR	1000000
 
-#define RX_DMA_PLEN0(_x)	(((_x) >> 16) & 0x3fff)
-#define RX_DMA_LSO		BIT(30)
+/* rxd2 */
 #define RX_DMA_DONE		BIT(31)
+#define RX_DMA_LSO		BIT(30)
+#define RX_DMA_PLEN0(_x)	(((_x) >> 16) & 0x3fff)
+#define RX_DMA_TAG		BIT(15)
+/* rxd3 */
+#define RX_DMA_TPID(_x)		(((_x) >> 16) & 0xffff)
+#define RX_DMA_VID(_x)		((_x) & 0xffff)
+/* rxd4 */
 #define RX_DMA_L4VALID		BIT(30)
 
 struct fe_rx_dma {
@@ -290,11 +322,12 @@
 	unsigned int rxd4;
 } __packed __aligned(4);
 
-#define TX_DMA_PLEN0_MASK	((0x3fff) << 16)
-#define TX_DMA_PLEN0(_x)	(((_x) & 0x3fff) << 16)
-#define TX_DMA_PLEN1(_x)	((_x) & 0x3fff)
-#define TX_DMA_GET_PLEN0(_x)    (((_x) >> 16 ) & 0x3fff)
-#define TX_DMA_GET_PLEN1(_x)    ((_x) & 0x3fff)
+#define TX_DMA_BUF_LEN		0x3fff
+#define TX_DMA_PLEN0_MASK	(TX_DMA_BUF_LEN << 16)
+#define TX_DMA_PLEN0(_x)	(((_x) & TX_DMA_BUF_LEN) << 16)
+#define TX_DMA_PLEN1(_x)	((_x) & TX_DMA_BUF_LEN)
+#define TX_DMA_GET_PLEN0(_x)    (((_x) >> 16 ) & TX_DMA_BUF_LEN)
+#define TX_DMA_GET_PLEN1(_x)    ((_x) & TX_DMA_BUF_LEN)
 #define TX_DMA_LS1		BIT(14)
 #define TX_DMA_LS0		BIT(30)
 #define TX_DMA_DONE		BIT(31)
@@ -353,8 +386,7 @@
 	void (*reset_fe)(void);
 	void (*set_mac)(struct fe_priv *priv, unsigned char *mac);
 	int (*fwd_config)(struct fe_priv *priv);
-	void (*tx_dma)(struct fe_priv *priv, int idx, struct sk_buff *skb);
-	void (*rx_dma)(struct fe_priv *priv, int idx, int len);
+	void (*tx_dma)(struct fe_tx_dma *txd);
 	int (*switch_init)(struct fe_priv *priv);
 	int (*switch_config)(struct fe_priv *priv);
 	void (*port_init)(struct fe_priv *priv, struct device_node *port);
@@ -367,15 +399,18 @@
 
 	void *swpriv;
 	u32 pdma_glo_cfg;
-	u32 rx_dly_int;
-	u32 tx_dly_int;
+	u32 rx_int;
+	u32 tx_int;
 	u32 checksum_bit;
-	u32 tx_udf_bit;
 };
 
 #define FE_FLAG_PADDING_64B		BIT(0)
 #define FE_FLAG_PADDING_BUG		BIT(1)
 #define FE_FLAG_JUMBO_FRAME		BIT(2)
+#define FE_FLAG_RX_2B_OFFSET		BIT(3)
+#define FE_FLAG_RX_SG_DMA		BIT(4)
+#define FE_FLAG_RX_VLAN_CTAG		BIT(5)
+#define FE_FLAG_NAPI_WEIGHT		BIT(6)
 
 #define FE_STAT_REG_DECLARE		\
 	_FE(tx_bytes)			\
@@ -400,6 +435,22 @@
 #undef _FE
 };
 
+enum fe_tx_flags {
+	FE_TX_FLAGS_SINGLE0	= 0x01,
+	FE_TX_FLAGS_PAGE0	= 0x02,
+	FE_TX_FLAGS_PAGE1	= 0x04,
+};
+
+struct fe_tx_buf
+{
+	struct sk_buff *skb;
+	u32 flags;
+	DEFINE_DMA_UNMAP_ADDR(dma_addr0);
+	DEFINE_DMA_UNMAP_LEN(dma_len0);
+	DEFINE_DMA_UNMAP_ADDR(dma_addr1);
+	DEFINE_DMA_UNMAP_LEN(dma_len1);
+};
+
 struct fe_priv
 {
 	spinlock_t			page_lock;
@@ -420,7 +471,7 @@
 	struct napi_struct		rx_napi;
 
 	struct fe_tx_dma		*tx_dma;
-	struct sk_buff			**tx_skb;
+	struct fe_tx_buf		*tx_buf;
 	dma_addr_t			tx_phys;
 	unsigned int			tx_free_idx;
 
@@ -433,6 +484,8 @@
 
 	struct fe_hw_stats		*hw_stats;
 	unsigned long			vlan_map;
+	struct work_struct		pending_work;
+	DECLARE_BITMAP(pending_flags, FE_FLAG_MAX);
 };
 
 extern const struct of_device_id of_fe_match[];
@@ -447,6 +500,8 @@
 void fe_reg_w32(u32 val, enum fe_reg reg);
 u32 fe_reg_r32(enum fe_reg reg);
 
+void fe_reset(u32 reset_bits);
+
 static inline void *priv_netdev(struct fe_priv *priv)
 {
 	return (char *)priv - ALIGN(sizeof(struct net_device), NETDEV_ALIGN);
Index: linux-3.10.49/drivers/net/ethernet/ralink/soc_mt7620.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/soc_mt7620.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/soc_mt7620.c
@@ -27,8 +27,8 @@
 
 #define MT7620A_CDMA_CSG_CFG	0x400
 #define MT7620_DMA_VID		(MT7620A_CDMA_CSG_CFG | 0x30)
-#define MT7621_DMA_VID		0xa8
-#define MT7620A_DMA_2B_OFFSET	BIT(31)
+#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
+#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
 #define MT7620A_RESET_FE	BIT(21)
 #define MT7621_RESET_FE		BIT(6)
 #define MT7620A_RESET_ESW	BIT(23)
@@ -39,8 +39,6 @@
 #define MT7621_TX_DMA_UDF	BIT(19)
 #define TX_DMA_FP_BMAP		((0xff) << 19)
 
-#define SYSC_REG_RESET_CTRL     0x34
-
 #define CDMA_ICS_EN		BIT(2)
 #define CDMA_UCS_EN		BIT(1)
 #define CDMA_TCS_EN		BIT(0)
@@ -72,9 +70,11 @@
 	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
 	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
 	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
 	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
 	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
 	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
 	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
 	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
 	[FE_REG_FE_DMA_VID_BASE] = MT7620_DMA_VID,
@@ -89,30 +89,26 @@
 	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
 	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
 	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
 	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
 	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
 	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
 	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
 	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
-	[FE_REG_FE_DMA_VID_BASE] = MT7621_DMA_VID,
+	[FE_REG_FE_DMA_VID_BASE] = 0,
 	[FE_REG_FE_COUNTER_BASE] = MT7621_GDM1_TX_GBCNT,
 	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
 };
 
 static void mt7620_fe_reset(void)
 {
-	u32 val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-
-	rt_sysc_w32(val | MT7620A_RESET_FE | MT7620A_RESET_ESW, SYSC_REG_RESET_CTRL);
-	rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+	fe_reset(MT7620A_RESET_FE | MT7620A_RESET_ESW);
 }
 
 static void mt7621_fe_reset(void)
 {
-	u32 val = rt_sysc_r32(SYSC_REG_RESET_CTRL);
-
-	rt_sysc_w32(val | MT7621_RESET_FE, SYSC_REG_RESET_CTRL);
-	rt_sysc_w32(val, SYSC_REG_RESET_CTRL);
+	fe_reset(MT7621_RESET_FE);
 }
 
 static void mt7620_rxcsum_config(bool enable)
@@ -139,6 +135,14 @@
 				MT7620A_CDMA_CSG_CFG);
 }
 
+static void mt7621_rxvlan_config(bool enable)
+{
+	if (enable)
+		fe_w32(1, MT7621_CDMP_EG_CTRL);
+	else
+		fe_w32(0, MT7621_CDMP_EG_CTRL);
+}
+
 static int mt7620_fwd_config(struct fe_priv *priv)
 {
 	struct net_device *dev = priv_netdev(priv);
@@ -157,25 +161,21 @@
 
 	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~0xffff, MT7620A_GDMA1_FWD_CFG);
 
-	mt7620_txcsum_config((dev->features & NETIF_F_IP_CSUM));
+	/* mt7621 don't have txcsum config */
 	mt7620_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+	mt7621_rxvlan_config((dev->features & NETIF_F_HW_VLAN_CTAG_RX) &&
+			(priv->flags & FE_FLAG_RX_VLAN_CTAG));
 
 	return 0;
 }
 
-static void mt7620_tx_dma(struct fe_priv *priv, int idx, struct sk_buff *skb)
-{
-	priv->tx_dma[idx].txd4 = 0;
-}
-
-static void mt7621_tx_dma(struct fe_priv *priv, int idx, struct sk_buff *skb)
+static void mt7620_tx_dma(struct fe_tx_dma *txd)
 {
-	priv->tx_dma[idx].txd4 = BIT(25);
 }
 
-static void mt7620_rx_dma(struct fe_priv *priv, int idx, int len)
+static void mt7621_tx_dma(struct fe_tx_dma *txd)
 {
-	priv->rx_dma[idx].rxd2 = RX_DMA_PLEN0(len);
+	txd->txd4 = BIT(25);
 }
 
 static void mt7620_init_data(struct fe_soc_data *data,
@@ -183,15 +183,29 @@
 {
 	struct fe_priv *priv = netdev_priv(netdev);
 
-	priv->flags = FE_FLAG_PADDING_64B;
+	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
+		FE_FLAG_RX_SG_DMA;
+
 	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
 		NETIF_F_HW_VLAN_CTAG_TX;
-
-	if (mt7620_get_eco() >= 5 || IS_ENABLED(CONFIG_SOC_MT7621))
+	if (mt7620_get_eco() >= 5)
 		netdev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 |
 			NETIF_F_IPV6_CSUM;
 }
 
+static void mt7621_init_data(struct fe_soc_data *data,
+		struct net_device *netdev)
+{
+	struct fe_priv *priv = netdev_priv(netdev);
+
+	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
+		FE_FLAG_RX_SG_DMA | FE_FLAG_NAPI_WEIGHT;
+
+	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
+		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_TSO |
+		NETIF_F_TSO6 | NETIF_F_IPV6_CSUM;
+}
+
 static void mt7621_set_mac(struct fe_priv *priv, unsigned char *mac)
 {
 	unsigned long flags;
@@ -210,16 +224,14 @@
 	.set_mac = mt7620_set_mac,
 	.fwd_config = mt7620_fwd_config,
 	.tx_dma = mt7620_tx_dma,
-	.rx_dma = mt7620_rx_dma,
 	.switch_init = mt7620_gsw_probe,
 	.switch_config = mt7620_gsw_config,
 	.port_init = mt7620_port_init,
 	.reg_table = mt7620_reg_table,
-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS | MT7620A_DMA_2B_OFFSET,
-	.rx_dly_int = RT5350_RX_DLY_INT,
-	.tx_dly_int = RT5350_TX_DLY_INT,
+	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
+	.rx_int = RT5350_RX_DONE_INT,
+	.tx_int = RT5350_TX_DONE_INT,
 	.checksum_bit = MT7620_L4_VALID,
-	.tx_udf_bit = MT7620_TX_DMA_UDF,
 	.has_carrier = mt7620a_has_carrier,
 	.mdio_read = mt7620_mdio_read,
 	.mdio_write = mt7620_mdio_write,
@@ -228,20 +240,18 @@
 
 static struct fe_soc_data mt7621_data = {
 	.mac = { 0x00, 0x11, 0x22, 0x33, 0x44, 0x55 },
-	.init_data = mt7620_init_data,
+	.init_data = mt7621_init_data,
 	.reset_fe = mt7621_fe_reset,
 	.set_mac = mt7621_set_mac,
 	.fwd_config = mt7621_fwd_config,
 	.tx_dma = mt7621_tx_dma,
-	.rx_dma = mt7620_rx_dma,
 	.switch_init = mt7620_gsw_probe,
 	.switch_config = mt7621_gsw_config,
 	.reg_table = mt7621_reg_table,
-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS | MT7620A_DMA_2B_OFFSET,
-	.rx_dly_int = RT5350_RX_DLY_INT,
-	.tx_dly_int = RT5350_TX_DLY_INT,
+	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
+	.rx_int = RT5350_RX_DONE_INT,
+	.tx_int = RT5350_TX_DONE_INT,
 	.checksum_bit = MT7621_L4_VALID,
-	.tx_udf_bit = MT7621_TX_DMA_UDF,
 	.has_carrier = mt7620a_has_carrier,
 	.mdio_read = mt7620_mdio_read,
 	.mdio_write = mt7620_mdio_write,
Index: linux-3.10.49/drivers/net/ethernet/ralink/soc_rt2880.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/soc_rt2880.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/soc_rt2880.c
@@ -22,7 +22,6 @@
 #include "ralink_soc_eth.h"
 #include "mdio_rt2880.h"
 
-#define SYSC_REG_RESET_CTRL		0x034
 #define RT2880_RESET_FE			BIT(18)
 
 static void rt2880_init_data(struct fe_soc_data *data,
@@ -39,7 +38,7 @@
 
 void rt2880_fe_reset(void)
 {
-	rt_sysc_w32(RT2880_RESET_FE, SYSC_REG_RESET_CTRL);
+	fe_reset(RT2880_RESET_FE);
 }
 
 static int rt2880_fwd_config(struct fe_priv *priv)
@@ -64,9 +63,8 @@
 	.fwd_config = rt2880_fwd_config,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,
-	.tx_udf_bit = TX_DMA_UDF,
-	.rx_dly_int = FE_RX_DLY_INT,
-	.tx_dly_int = FE_TX_DLY_INT,
+	.rx_int = FE_RX_DONE_INT,
+	.tx_int = FE_TX_DONE_INT,
 	.mdio_read = rt2880_mdio_read,
 	.mdio_write = rt2880_mdio_write,
 	.mdio_adjust_link = rt2880_mdio_link_adjust,
Index: linux-3.10.49/drivers/net/ethernet/ralink/soc_rt305x.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/soc_rt305x.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/soc_rt305x.c
@@ -24,7 +24,6 @@
 
 #define RT305X_RESET_FE         BIT(21)
 #define RT305X_RESET_ESW        BIT(23)
-#define SYSC_REG_RESET_CTRL     0x034
 
 static const u32 rt5350_reg_table[FE_REG_COUNT] = {
 	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
@@ -33,9 +32,11 @@
 	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
 	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
 	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
+	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
 	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
 	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
 	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
+	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
 	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
 	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
 	[FE_REG_FE_RST_GL] = 0,
@@ -72,8 +73,7 @@
 
 static void rt305x_fe_reset(void)
 {
-	rt_sysc_w32(RT305X_RESET_FE, SYSC_REG_RESET_CTRL);
-	rt_sysc_w32(0, SYSC_REG_RESET_CTRL);
+	fe_reset(RT305X_RESET_FE);
 }
 
 static void rt5350_init_data(struct fe_soc_data *data,
@@ -114,15 +114,14 @@
 	return 0;
 }
 
-static void rt5350_tx_dma(struct fe_priv *priv, int idx, struct sk_buff *skb)
+static void rt5350_tx_dma(struct fe_tx_dma *txd)
 {
-	priv->tx_dma[idx].txd4 = 0;
+	txd->txd4 = 0;
 }
 
 static void rt5350_fe_reset(void)
 {
-	rt_sysc_w32(RT305X_RESET_FE | RT305X_RESET_ESW, SYSC_REG_RESET_CTRL);
-	rt_sysc_w32(0, SYSC_REG_RESET_CTRL);
+	fe_reset(RT305X_RESET_FE | RT305X_RESET_ESW);
 }
 
 static struct fe_soc_data rt3050_data = {
@@ -132,9 +131,8 @@
 	.fwd_config = rt3050_fwd_config,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,
-	.tx_udf_bit = TX_DMA_UDF,
-	.rx_dly_int = FE_RX_DLY_INT,
-	.tx_dly_int = FE_TX_DLY_INT,
+	.rx_int = FE_RX_DONE_INT,
+	.tx_int = FE_TX_DONE_INT,
 };
 
 static struct fe_soc_data rt5350_data = {
@@ -147,9 +145,8 @@
 	.tx_dma = rt5350_tx_dma,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
 	.checksum_bit = RX_DMA_L4VALID,
-	.tx_udf_bit = TX_DMA_UDF,
-	.rx_dly_int = RT5350_RX_DLY_INT,
-	.tx_dly_int = RT5350_TX_DLY_INT,
+	.rx_int = RT5350_RX_DONE_INT,
+	.tx_int = RT5350_TX_DONE_INT,
 };
 
 const struct of_device_id of_fe_match[] = {
Index: linux-3.10.49/drivers/net/ethernet/ralink/soc_rt3883.c
===================================================================
--- linux-3.10.49/drivers/net/ethernet/ralink/soc_rt3883.c
+++ linux-3.10.49/drivers/net/ethernet/ralink/soc_rt3883.c
@@ -22,19 +22,11 @@
 #include "ralink_soc_eth.h"
 #include "mdio_rt2880.h"
 
-#define RT3883_SYSC_REG_RSTCTRL		0x34
 #define RT3883_RSTCTRL_FE		BIT(21)
 
 static void rt3883_fe_reset(void)
 {
-	u32 t;
-
-	t = rt_sysc_r32(RT3883_SYSC_REG_RSTCTRL);
-	t |= RT3883_RSTCTRL_FE;
-	rt_sysc_w32(t , RT3883_SYSC_REG_RSTCTRL);
-
-	t &= ~RT3883_RSTCTRL_FE;
-	rt_sysc_w32(t, RT3883_SYSC_REG_RSTCTRL);
+	fe_reset(RT3883_RSTCTRL_FE);
 }
 
 static int rt3883_fwd_config(struct fe_priv *priv)
@@ -69,10 +61,9 @@
 	.reset_fe = rt3883_fe_reset,
 	.fwd_config = rt3883_fwd_config,
 	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
-	.rx_dly_int = FE_RX_DLY_INT,
-	.tx_dly_int = FE_TX_DLY_INT,
+	.rx_int = FE_RX_DONE_INT,
+	.tx_int = FE_TX_DONE_INT,
 	.checksum_bit = RX_DMA_L4VALID,
-	.tx_udf_bit = TX_DMA_UDF,
 	.mdio_read = rt2880_mdio_read,
 	.mdio_write = rt2880_mdio_write,
 	.mdio_adjust_link = rt2880_mdio_link_adjust,
